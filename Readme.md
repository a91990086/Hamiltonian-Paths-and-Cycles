Hamiltonian Cycles and Paths
===

This project is intended to be a survey on different algorithms and approaches, 
including both deterministic and heuristic, to solve the Hamiltonian path or cycle problem.

#### What is a Hamiltonian Path/Cycle

A Hamiltoninan path is defined to be a path in a graph that travels from 
a starting point to a end point and pass through every single node (or vertex) exactly once. \
A Hamiltonian cycle is a Hamiltonian path that starts and ends at the same point.

#### From Hamiltonian Cycle to Hamiltonian Path

One way to apply Hamiltonian cycle algorithms to Hamiltonian path problem is to connect the start and end with a node.
Namely, create one node, we will name it Vc, create an edge between Vc and start and another edge between Vc and end.
When a Hamiltonian cycle is found, one can simply remove the added node to obtain a Hamiltonian path from start to end.

Code and Algorithms
===

Three approaches are implemented in this project. This first one is a deterministic dynamic programming algorithm, 
second one is a heuristic based on the rotation-extension approach, 
and the last one is a combination of the rotation approach and greedy depth first search.

#### DynamicProgramming.py
This is an implementation of the dynamic programming approach suggested by Bellman, Held, and Karp in 1962. 
The idea is to build up our knowledge of a graph using power sets. 

For example if we know that we have a path that travels through the subset {1, 2, 3} 
exactly once and end up at one of the nodes within the subset, we can simply examine this subset 
later when we extend the path further. 
One can think of this algorithm as using power sets as building blocks to simplify the problem.

[Here's a link to a good tutorial](https://www.hackerearth.com/practice/algorithms/graphs/hamiltonian-path/tutorial/)

- This is an exact algorith. It will return ALL Hamiltonian path. That is, if we have the time.

- The time complexity of this method is O(2^n $n^2$) 

    - This is because we need to iterate through the power set of n

- To put everthing into perspective, I found some numbers on Wikipedia

    - 1E10 -- Bacteria in the human body
    - 1E12 -- Number of stars in Andromeda Galaxy
    - 1E18 -- Computational limit of a 64-bit CPU
    - 1E24 -- Number of stars in the observable universe
    - 1E30 -- 2^100

Now, we are not going to sit there and count the number of stars in the galaxy while waiting for the code to run.
If you are not convinced, I have added a power set iterator program (PowerSetIteration.py) to the repo.
 You can try to see how long it takes just to iterate through 2^100. (Please don't.)


#### HAM.py
This is an implementation of the paper An Algorithm for Finding Hamilton Paths and Cycles suggested by B. Bollobas. 
This is a heuristic approach that solves the Hamiltonian cycle/path problem in a probabilistic sense. Variations of this
heuristic have proven to have running time of O(n). Note that theorectically, HAM algorithm requires a random graph generated 
by a specific graph model (because of the brobabillistic approach).

[Here is the link to the paper](https://www.math.cmu.edu/~af1p/Texfiles/AFFHCIRG.pdf)

Also some good references: \
[Lecture Note by NTHU](http://www.cs.nthu.edu.tw/~wkhon/random12/lecture/lecture16.pdf) \
[Lecture Note by TUT](http://www.cs.tut.fi/~elomaa/teach/RandAl-15-6.pdf)


#### HybridHAM.py
This is an implementation of the the paper HybridHAM: A Novel Hybrid Heuristic for Finding Hamiltonian Cycle
suggested by K. R. Seeja recently. The worst time complexity of this method is O(n^3)

[Here is the link to the paper](https://www.hindawi.com/journals/jopti/2018/9328103/)


Dataset
===

I use the TSP and HCP Benchmark set proposed by Baniasadi. You can download it [here](https://sites.flinders.edu.au/flinders-hamiltonian-cycle-project/tsp-and-hcp-benchmark-set/) \
Please extract the dataset to master/tsphcp.

I tested the dataset with both HAM and HybridHAM.
Since HAM requires a random graph generated by a specific graph model, it is expected to fail on the test set.
From my testing, HAM works for none of the test set examples, while HybridHAM works pretty well for ~100 vertices.
None of the algorithm I implemented is able to solve HC/HP problem with 200+ vertices.